**提示词开始**

 **项目背景** ：
你正在参与MeetHub后端项目开发，该项目基于FastAPI + Tortoise-ORM + Pydantic技术栈。第一阶段已完成基础架构搭建，包括：

* 数据模型层（Users、Roles）
* 模式层（Schemas）
* 数据访问层（DAO）
* 应用接口层（Apps）

 **当前任务** ：
基于现有稳定架构，开发完整的JWT认证组件——重点实现登录接口功能。

 **开发流程与要求** ：

### 第一阶段：开发JWT核心工具组件

**1. JWT令牌生成工具**

* **文件位置** ：`core/security/jwt_handler.py`
* **命名规范** ：
* 类：`JWTTokenHandler`
* 方法：`create_access_token()`, `create_refresh_token()`
* **引入库** ：
  **python**

  复制

  下载

```
  import jwt
  from datetime import datetime, timedelta
  from typing import Dict, Any
  from config.settings import settings  # 假设有配置管理
```

* **核心逻辑结构** ：
  **python**

  复制

  下载

```
  class JWTTokenHandler:
      def __init__(self):
          self.secret_key = settings.JWT_SECRET_KEY
          self.algorithm = settings.JWT_ALGORITHM
          self.access_token_expire = settings.ACCESS_TOKEN_EXPIRE_MINUTES
          self.refresh_token_expire = settings.REFRESH_TOKEN_EXPIRE_DAYS
    
      def create_access_token(self, data: Dict[str, Any]) -> str:
          # 1. 复制数据并添加过期时间
          # 2. 使用jwt.encode生成令牌
          # 3. 返回令牌字符串
    
      def create_refresh_token(self, data: Dict[str, Any]) -> str:
          # 类似access_token，但使用不同的过期时间
```

**2. JWT令牌验证工具**

* **文件位置** ：`core/security/jwt_validator.py`
* **命名规范** ：
* 类：`JWTTokenValidator`
* 方法：`verify_token()`, `decode_token()`, `get_current_user()`
* **核心逻辑结构** ：
  **python**

  复制

  下载

```
  class JWTTokenValidator:
      def __init__(self):
          self.secret_key = settings.JWT_SECRET_KEY
          self.algorithm = settings.JWT_ALGORITHM
    
      async def verify_token(self, token: str) -> bool:
          # 1. 尝试解码令牌
          # 2. 验证签名和过期时间
          # 3. 返回验证结果
    
      async def get_current_user(self, token: str) -> Users:
          # 1. 解码令牌获取用户ID
          # 2. 使用UsersDAO查询用户信息
          # 3. 返回用户对象或抛出异常
```

### 第二阶段：开发密码验证工具

**3. 密码哈希与验证工具**

* **文件位置** ：`core/security/password_utils.py`
* **引入库** ：`passlib[bcrypt]`
* **核心功能** ：
  **python**

  复制

  下载

```
  from passlib.context import CryptContext

  pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

  def verify_password(plain_password: str, hashed_password: str) -> bool:
      return pwd_context.verify(plain_password, hashed_password)

  def get_password_hash(password: str) -> str:
      return pwd_context.hash(password)
```

### 第三阶段：开发用户登录接口

**4. 登录路由与业务逻辑**

* **文件位置** ：`apps/auth/views.py`
* **路由路径** ：`POST /api/v1/auth/login`
* **请求模式** ：创建 `LoginRequest` Schema
* **响应模式** ：创建 `TokenResponse` Schema
* **核心逻辑** ：
  **python**

  复制

  下载

```
  @router.post("/login", response_model=TokenResponse)
  async def login(login_data: LoginRequest):
      # 1. 使用UsersDAO根据用户名/邮箱查找用户
      # 2. 验证用户状态（是否激活）
      # 3. 使用password_utils验证密码
      # 4. 生成access_token和refresh_token
      # 5. 更新用户最后登录时间
      # 6. 返回令牌响应
```

### 第四阶段：开发JWT认证中间件

**5. JWT认证中间件**

* **文件位置** ：`core/middleware/auth_middleware.py`
* **命名规范** ：`JWTAuthMiddleware`
* **核心逻辑** ：
  **python**

  复制

  下载

```
  class JWTAuthMiddleware:
      def __init__(self, app):
          self.app = app
    
      async def __call__(self, scope, receive, send):
          # 1. 检查请求路径是否需要认证
          # 2. 从Header提取Authorization令牌
          # 3. 使用JWTTokenValidator验证令牌
          # 4. 将用户信息添加到请求状态
          # 5. 继续处理请求或返回401错误
```

### 开发规范要求：

1. **错误处理** ：

* 使用自定义异常类（如 `AuthException`）
* 统一的错误响应格式
* 详细的错误日志记录

1. **配置管理** ：

* JWT密钥、算法、过期时间从配置读取
* 支持开发/生产环境不同配置

1. **依赖注入** ：

* 使用FastAPI的Depends注入认证依赖
* 创建 `get_current_user`依赖函数

1. **测试覆盖** ：

* 为每个组件编写单元测试
* 测试文件位置：`tests/auth/`

 **验收标准** ：

* 用户能够使用用户名/密码成功登录并获得JWT令牌
* 受保护接口能够正确验证JWT令牌
* 令牌过期或无效时返回适当的错误信息
* 代码结构清晰，符合项目现有架构风格
* 完整的错误处理和日志记录

**请按照上述流程和规范，逐步开发JWT认证组件，确保每个组件都经过充分测试后再进入下一阶段。**

---

**提示词结束**
