# 推荐算法接口开发指南

## 一、概述

### 目标

开发一个推荐算法核心接口，根据用户标签与用户行为，为用户推荐5个可能感兴趣的活动。

### 核心特性

- ✅ 基于用户标签的内容过滤
- ✅ 基于用户行为的协同过滤
- ✅ 热度排序与新鲜度考虑
- ✅ 个性化推荐理由说明
- ✅ 灵活的推荐参数调整

---

## 二、需要开发的组件清单

### 2.1 数据访问层 (DAO)

#### 文件：`dao/recommendation_dao.py` (新建)

**主要功能**：

```python
class RecommendationDAO:
    # 获取用户已浏览的活动ID列表（去重）
    async def get_user_viewed_activities(user_id: int) -> List[int]
  
    # 获取用户已报名的活动ID列表（去重）
    async def get_user_registered_activities(user_id: int) -> List[int]
  
    # 获取用户行为统计
    async def get_user_behavior_stats(user_id: int) -> Dict
  
    # 获取所有可推荐的活动（未删除、已发布）
    async def get_available_activities(limit: int = 1000) -> List[Activity]
  
    # 计算活动热度分数
    async def get_activity_hotness(activity_id: int) -> float
  
    # 获取相似用户（基于共同浏览/报名活动）
    async def get_similar_users(user_id: int, limit: int = 20) -> List[int]
  
    # 批量获取活动的浏览/报名人数
    async def get_activity_stats_batch(activity_ids: List[int]) -> Dict
```

---

### 2.2 推荐引擎 (Core)

#### 目录：`core/recommendation/` (新建)

#### 文件：`core/recommendation/recommendation_engine.py`

**核心推荐算法实现**：

```python
class RecommendationEngine:
    """
    多层推荐算法引擎
    """
  
    # 主推荐方法
    async def recommend_for_user(
        user_id: int,
        limit: int = 5,
        weights: Dict = None
    ) -> List[RecommendationItem]
  
    # 第1层：内容过滤 - 匹配用户标签与活动受众
    async def content_filtering(
        user_profile: Dict,
        candidate_activities: List[Activity]
    ) -> List[Activity]
  
    # 第2层：热度排序
    async def popularity_scoring(
        activities: List[Activity]
    ) -> List[Tuple[Activity, float]]
  
    # 第3层：协同过滤 - 基于相似用户
    async def collaborative_filtering(
        user_id: int,
        activities: List[Activity],
        similar_user_limit: int = 10
    ) -> Dict[int, float]
  
    # 第4层：时间衰减 - 优先推荐新活动
    async def time_decay_scoring(
        activities: List[Activity]
    ) -> Dict[int, float]
  
    # 综合打分
    async def composite_scoring(
        activities: List[Activity],
        content_scores: Dict,
        popularity_scores: Dict,
        collaborative_scores: Dict,
        time_scores: Dict,
        weights: Dict
    ) -> List[RecommendationItem]
```

#### 文件：`core/recommendation/scoring_utils.py`

**辅助打分工具**：

```python
class ScoringUtils:
    # 计算标签匹配度
    @staticmethod
    def calculate_tag_match(user_tags: List[str], activity_audience: Dict) -> float
  
    # 计算热度分数（0-1）
    @staticmethod
    def calculate_hotness(views_count: int, participants: int, max_views: int) -> float
  
    # 计算时间衰减分数
    @staticmethod
    def calculate_time_decay(activity_start_time: datetime) -> float
  
    # 计算向量相似度（用于协同过滤）
    @staticmethod
    def calculate_cosine_similarity(vec1: List[float], vec2: List[float]) -> float
  
    # 多因子加权融合
    @staticmethod
    def weighted_fusion(scores_dict: Dict[str, float], weights: Dict[str, float]) -> float
```

---

### 2.3 数据模型 (Schemas)

#### 文件：`schemas/recommendations.py` (新建)

```python
from pydantic import BaseModel
from typing import List, Dict, Optional
from datetime import datetime

# 推荐请求
class RecommendationRequest(BaseModel):
    limit: int = 5  # 推荐数量
    exclude_registered: bool = True  # 排除已报名的活动
    exclude_viewed: bool = False  # 排除已浏览的活动
  
class RecommendationParamsRequest(BaseModel):
    """用于调试推荐参数的高级请求"""
    limit: int = 5
    weights: Dict[str, float] = {
        "content_match": 0.3,      # 内容匹配度
        "popularity": 0.3,         # 热度
        "collaborative": 0.2,      # 协同过滤
        "time_decay": 0.2          # 时间衰减
    }
    exclude_registered: bool = True
    exclude_viewed: bool = False

# 推荐项目（包含推荐理由）
class RecommendationItem(BaseModel):
    activity_id: int
    activity_title: str
    activity_description: str
    activity_image: str
    start_time: datetime
    max_participants: int
    current_participants: int
    location: str
  
    # 推荐相关
    score: float  # 综合推荐分数（0-100）
    reasons: List[str]  # 推荐理由列表
    match_percentage: float  # 匹配度（0-100%）
  
    class Config:
        from_attributes = True

# 推荐响应
class RecommendationResponse(BaseModel):
    success: bool
    message: str
    user_id: int
    total_recommendations: int
    recommendations: List[RecommendationItem]
  
    class Meta:
        description = "推荐算法响应模型"
```

---

### 2.4 路由接口 (Routers)

#### 文件：`routers/recommendations.py` (新建)

```python
from fastapi import APIRouter, Depends, HTTPException, Query, Request, status
from schemas.recommendations import (
    RecommendationRequest,
    RecommendationResponse,
    RecommendationParamsRequest
)
from core.recommendation.recommendation_engine import RecommendationEngine
from core.middleware.auth_middleware import JWTAuthMiddleware
from core.permission_checker import requires_permissions
from typing import Optional, Dict

router = APIRouter(
    prefix="/recommendations",
    tags=["推荐"],
    dependencies=[Depends(JWTAuthMiddleware())]
)

recommendation_engine = RecommendationEngine()

# 接口1：为当前用户推荐活动
@router.get(
    "/for-me",
    response_model=RecommendationResponse,
    status_code=status.HTTP_200_OK
)
async def get_recommendations_for_me(
    request: Request,
    limit: int = Query(5, ge=1, le=20, description="推荐数量"),
    exclude_registered: bool = Query(True, description="排除已报名的活动"),
    exclude_viewed: bool = Query(False, description="排除已浏览的活动")
):
    """
    为当前登录用户获取个性化推荐
  
    - 基于用户标签进行内容过滤
    - 基于用户历史行为进行协同过滤
    - 综合考虑活动热度和新鲜度
    - 返回推荐活动及推荐理由
  
    参数说明：
    - limit: 推荐活动数量（1-20）
    - exclude_registered: 是否排除已报名的活动
    - exclude_viewed: 是否排除已浏览的活动
    """
    try:
        user_id = request.state.user.id
      
        recommendations = await recommendation_engine.recommend_for_user(
            user_id=user_id,
            limit=limit,
            exclude_registered=exclude_registered,
            exclude_viewed=exclude_viewed
        )
      
        return RecommendationResponse(
            success=True,
            message="推荐成功",
            user_id=user_id,
            total_recommendations=len(recommendations),
            recommendations=recommendations
        )
      
    except HTTPException as he:
        raise he
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"获取推荐失败: {str(e)}"
        )

# 接口2：带参数的推荐（用于调试和参数优化）
@router.post(
    "/calculate",
    response_model=RecommendationResponse,
    status_code=status.HTTP_200_OK,
    dependencies=[requires_permissions(["recommendation:debug"])]
)
async def calculate_recommendations_with_params(
    request: Request,
    params: RecommendationParamsRequest
):
    """
    使用自定义参数计算推荐（用于调试和算法优化）
  
    - 允许调整各个打分因子的权重
    - 返回详细的打分信息
    - 需要管理员权限
  
    权重说明：
    - content_match: 内容匹配度（用户标签与活动受众的匹配）
    - popularity: 活动热度（浏览量、报名人数）
    - collaborative: 协同过滤（相似用户的行为）
    - time_decay: 时间衰减（优先推荐近期活动）
    """
    try:
        user_id = request.state.user.id
      
        # 验证权重总和
        total_weight = sum(params.weights.values())
        if not (0.99 < total_weight < 1.01):  # 允许浮点数误差
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"权重总和必须为1.0，当前为{total_weight}"
            )
      
        recommendations = await recommendation_engine.recommend_for_user(
            user_id=user_id,
            limit=params.limit,
            weights=params.weights,
            exclude_registered=params.exclude_registered,
            exclude_viewed=params.exclude_viewed
        )
      
        return RecommendationResponse(
            success=True,
            message="推荐计算成功",
            user_id=user_id,
            total_recommendations=len(recommendations),
            recommendations=recommendations
        )
      
    except HTTPException as he:
        raise he
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"计算推荐失败: {str(e)}"
        )
```

---

## 三、推荐算法详细设计

### 3.1 整体流程

```
用户请求推荐
    ↓
[第1步] 数据准备
    ├─ 获取用户基本信息（标签、兴趣）
    ├─ 获取用户行为历史（已浏览、已报名）
    └─ 获取所有可推荐活动
    ↓
[第2步] 候选活动过滤
    ├─ 排除已报名/已浏览的活动（可选）
    ├─ 排除已结束的活动
    └─ 排除用户不符合条件的活动
    ↓
[第3步] 多层打分
    ├─ 内容匹配打分（用户标签 vs 活动受众）
    ├─ 热度打分（浏览量、报名人数）
    ├─ 协同过滤打分（相似用户的行为）
    └─ 时间衰减打分（新鲜度）
    ↓
[第4步] 权重融合
    └─ 综合得分 = Σ(各层得分 × 权重)
    ↓
[第5步] 排序和选择
    ├─ 按综合得分排序
    └─ 取前N个活动
    ↓
[第6步] 生成推荐理由
    └─ 为每个推荐活动生成人类可读的推荐理由
    ↓
返回推荐结果
```

### 3.2 推荐理由示例

```
推荐理由类型：
1. 标签匹配型：
   - "您的兴趣标签与该活动目标人群高度匹配"
   - "符合您关注的大一/计算机专业类活动"

2. 热度型：
   - "该活动浏览量高（523次），说明热度很高"
   - "已有45人报名，热度排名前15%"

3. 协同型：
   - "与您兴趣相似的10位用户都浏览过此活动"
   - "与您兴趣相似的5位用户已报名此活动"

4. 新鲜度型：
   - "该活动即将开始（还有3天）"
   - "该活动刚发布，新鲜推荐"

5. 综合型：
   - "综合推荐指数86分，是您的高匹配活动"
```

---

## 四、权重参数说明

### 默认权重配置

```json
{
  "content_match": 0.3,      // 30% - 用户标签与活动受众的匹配度
  "popularity": 0.3,         // 30% - 活动的热度和受欢迎程度
  "collaborative": 0.2,      // 20% - 相似用户的浏览/报名行为
  "time_decay": 0.2          // 20% - 时间衰减（优先推荐新活动）
}
```

### 权重调整建议

**场景1：新用户冷启动**

```json
{
  "content_match": 0.4,      // 提高标签匹配权重
  "popularity": 0.4,         // 推荐热门活动
  "collaborative": 0.1,      // 降低协同权重（用户太新）
  "time_decay": 0.1
}
```

**场景2：资深用户个性化**

```json
{
  "content_match": 0.2,      // 降低标签权重（已充分匹配）
  "popularity": 0.2,         // 降低热度权重（更需要发现新活动）
  "collaborative": 0.4,      // 提高协同权重（已有行为历史）
  "time_decay": 0.2
}
```

**场景3：发现新活动模式**

```json
{
  "content_match": 0.2,
  "popularity": 0.1,         // 降低热度权重
  "collaborative": 0.2,
  "time_decay": 0.5          // 大幅提高新鲜度权重
}
```

---

## 五、集成到现有项目

### 5.1 注册路由 (main.py)

```python
# 在 main.py 中添加推荐路由
from routers.recommendations import router as recommendations_router

app.include_router(recommendations_router)
```

### 5.2 权限配置 (core/permissions.py)

```python
# 添加推荐相关权限
RECOMMENDATION_READ = "recommendation:read"
RECOMMENDATION_DEBUG = "recommendation:debug"
```

### 5.3 依赖关系

```
推荐接口 (routers/recommendations.py)
    ↓
推荐引擎 (core/recommendation/recommendation_engine.py)
    ├─ 推荐DAO (dao/recommendation_dao.py)
    │   ├─ UserOperationLogsDAO
    │   ├─ ActivityDAO
    │   └─ UserDAO
    ├─ 打分工具 (core/recommendation/scoring_utils.py)
    └─ 认证中间件 (core/middleware/auth_middleware.py)
```

---

## 六、使用示例

### 6.1 基础推荐

```bash
# 获取为当前用户推荐的5个活动
curl -X GET "http://localhost:8000/recommendations/for-me?limit=5" \
  -H "Authorization: Bearer <token>"
```

**响应示例**：

```json
{
  "success": true,
  "message": "推荐成功",
  "user_id": 100,
  "total_recommendations": 5,
  "recommendations": [
    {
      "activity_id": 51,
      "activity_title": "端午鉴非遗雅礼承东风端午节主题文化活动",
      "score": 92.5,
      "reasons": [
        "您的兴趣标签与该活动高度匹配",
        "该活动热度很高（已有36人浏览）",
        "与您兴趣相似的8位用户都浏览过此活动"
      ],
      "match_percentage": 92.5
    },
    {
      "activity_id": 52,
      "activity_title": "制扇致美劳动最美团扇手作沙龙活动",
      "score": 85.3,
      "reasons": [
        "符合您关注的社会实践类活动",
        "该活动即将开始（还有4天）"
      ],
      "match_percentage": 85.3
    }
    // ... 更多推荐
  ]
}
```

### 6.2 高级推荐（调试参数）

```bash
curl -X POST "http://localhost:8000/recommendations/calculate" \
  -H "Authorization: Bearer <admin_token>" \
  -H "Content-Type: application/json" \
  -d '{
    "limit": 5,
    "weights": {
      "content_match": 0.4,
      "popularity": 0.2,
      "collaborative": 0.2,
      "time_decay": 0.2
    },
    "exclude_registered": true,
    "exclude_viewed": false
  }'
```

---

## 七、性能优化建议

### 7.1 缓存策略

```python
# 缓存用户行为数据（1小时）
@cached(cache=TTLCache(maxsize=10000, ttl=3600))
async def get_user_behavior_stats(user_id: int):
    pass

# 缓存活动热度数据（30分钟）
@cached(cache=TTLCache(maxsize=1000, ttl=1800))
async def get_activity_hotness_batch(activity_ids: List[int]):
    pass
```

### 7.2 异步批处理

```python
# 批量获取活动统计，减少数据库查询
activity_stats = await get_activity_stats_batch(candidate_activity_ids)
```

### 7.3 数据库索引

```sql
-- 在 user_operation_logs 上创建索引
CREATE INDEX idx_user_operation_type ON user_operation_logs(user_id, operation_type);
CREATE INDEX idx_activity_view_count ON activities(views_count, current_participants);
```

---

## 八、测试建议

### 8.1 单元测试

```python
# tests/test_recommendation_engine.py
async def test_content_filtering():
    """测试内容过滤"""
    pass

async def test_popularity_scoring():
    """测试热度打分"""
    pass

async def test_collaborative_filtering():
    """测试协同过滤"""
    pass

async def test_composite_scoring():
    """测试综合打分"""
    pass
```

### 8.2 集成测试

```python
async def test_full_recommendation_flow():
    """测试完整推荐流程"""
    pass

async def test_recommendation_with_custom_weights():
    """测试自定义权重"""
    pass
```

---

## 九、后续优化方向

1. **机器学习增强**

   - 使用用户点击、停留时间等数据训练模型
   - 实现深度学习推荐模型
2. **实时更新**

   - 使用消息队列处理日志记录
   - 实时更新推荐模型
3. **A/B测试**

   - 支持多个推荐算法版本
   - 自动选择最优版本
4. **多模态推荐**

   - 结合用户画像、活动内容、季节性等因素
   - 社交推荐（好友参与的活动）
5. **隐私保护**

   - 本地推荐计算
   - 匿名化处理用户数据

---

**创建日期**：2025年11月14日
**维护者**：推荐系统小组
**相关文档**：[用户操作日志功能清单](用户操作日志功能清单.md)、[用户操作日志设计文档](用户操作日志设计文档.md)
