### **第一阶段：项目奠基与建模**

这个阶段的目标是 **让项目跑起来** ，并建立最核心的数据结构。

1. **项目初始化**

   * 创建虚拟环境，安装基础依赖：`fastapi`, `uvicorn`, `sqlalchemy`, `pymysql`, `python-jose` (JWT), `passlib` (密码哈希)。
   * 规划项目目录结构（例如：`models/`, `routers/`, `schemas/`, `dependencies.py`）。
2. **数据库模型设计（最核心的一步）**

   * **只创建最基础的表** ：`users`, `roles`。
   * 建立 **用户和角色的多对多关系** （通过中间表 `user_roles`）。
   * **先不要创建 `permissions` 表！** 避免一开始就过度设计。
   * 在 `roles` 表中添加一个 `permissions` 的 **JSON 字段** 或一个简单的 `String` 字段。这是关键技巧！
     * **JSON 字段示例** ：`["user:create", "user:read", "post:delete"]`
     * **字符串字段示例** ：`"admin,editor,viewer"` (用逗号分隔)

   **为什么这么做？** 在初期，这极大地简化了开发。你不需要维护复杂的权限关系表，可以直接通过修改角色记录来分配权限。**这符合MVP（最小可行产品）原则。**
3. **搭建API框架与工具函数**

   * 创建数据库连接和会话。
   * 创建Pydantic模型（Schemas）用于请求和响应验证。
   * 编写几个简单的CRUD接口，例如创建用户、获取用户列表。此时 **完全不涉及权限验证** 。

### **第二阶段：实现用户认证**

这个阶段的目标是 **知道是谁在访问API** 。

1. **密码哈希**
   * 使用 `passlib` 的 `bcrypt` 上下文。
   * 在创建用户的逻辑中，确保密码是经过哈希处理后才存入数据库的。
2. **登录与JWT签发**
   * 创建 `/login` 端点，验证用户名和密码。
   * 验证成功后，生成一个JWT令牌。这个JWT的 **Payload（负载）** 中应该包含最重要的信息：`{"sub": user_id, "role": role_name}`。
   * 将JWT返回给前端。
3. **创建认证依赖项**
   * 编写一个FastAPI的 `Depends` 函数（例如 `get_current_user`）。
   * 这个函数会从请求头中提取JWT，验证其有效性，然后从数据库中查出对应的 `user` 对象。
   * 将这个 `user` 对象注入到需要认证的路径操作函数中。

### **第三阶段：注入RBAC核心**

现在你知道了“谁”在访问，接下来要搞清楚他“有什么”。

1. **完善权限模型**
   * 此时，你可以重新审视 `roles` 表中的 `permissions` 字段。定义清晰的权限字符串格式，例如 `资源:操作`（`"article:create"`, `"user:delete"`）。
   * 编写一个辅助函数，例如 `def user_has_permission(user: User, required_permission: str) -> bool`。这个函数会：
     1. 获取用户的角色。
     2. 从角色的 `permissions` 字段中解析出权限列表。
     3. 检查 `required_permission` 是否在列表中。
2. **创建角色和权限管理接口（后端）**
   * `POST /roles` - 创建新角色（同时指定权限列表）
   * `GET /roles` - 获取角色列表
   * `PUT /roles/{role_id}` - 更新角色的权限
   * `POST /users/{user_id}/roles` - 为用户分配角色
   * **注意：** 这些接口本身应该是受保护的，只有超级管理员才能访问。

### **第四阶段：实现权限验证**

这是将认证和授权连接起来的最后一步。

1. **创建权限检查依赖项**
   * 编写另一个 `Depends` 函数（例如 `get_current_active_user` 的升级版，或一个新的 `require_permission`）。
   * 它依赖于 `get_current_user`，拿到当前用户后，再调用 `user_has_permission` 函数。
   * 如果用户没有所需权限，则直接抛出 `HTTPException(status_code=403, detail="Not enough permissions")`。
2. **保护API端点**
   * 在你的路径操作中，使用这个新的依赖项。
   * **示例：**
     **python**

     复制

     下载

     ```
     @app.post("/articles/", dependencies=[Depends(require_permission("article:create"))])
     async def create_article(...):
         ...
     ```

### **第五阶段：迭代与完善**

基础系统搭建完毕后，再根据需求进行增强。

1. **构建简单的前端管理界面** ：用于管理用户、角色和权限。
2. **数据级权限** ：从“能否操作文章”细化到“能否操作**自己创建的**文章”。
3. **引入缓存** ：将用户的角色和权限信息放入Redis，避免每次请求都查询数据库。
4. **日志与审计** ：记录关键操作。
5. **编写文档和测试** 。

**核心建议：**

* **不要试图一步到位** ，尤其是那个复杂的 `users` <-> `roles` <-> `permissions` <-> `resources` 模型。从简单的JSON字段开始，当你的业务真正需要更细粒度的动态控制时，再重构到那个经典模型。
* **每完成一个阶段，都进行测试** ，确保它稳定工作后再进入下一阶段。

遵循这个路线图，你将能清晰地、一步一个脚印地构建起整个RBAC系统。
